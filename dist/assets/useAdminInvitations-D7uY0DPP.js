import{a as reactExports}from"./react-vendor-C9V0vZuX.js";import{R as useAuth,a2 as useUserManagement,au as query,az as orderBy,Y as collection,aw as onSnapshot,aC as Timestamp,X as addDoc,a6 as getDoc,a5 as doc,a8 as updateDoc,aD as setDoc,W as serverTimestamp,a7 as USER_ROLES,av as where,ax as getDocs,aE as limit,Z as db}from"./index-CSaj8tEt.js";const DEFAULT_TOKEN_BYTE_LENGTH=32,DEFAULT_TOKEN_TTL_HOURS=168,HEX_TOKEN_REGEX=/^[a-f0-9]+$/i;function getCrypto(){return"undefined"!=typeof globalThis&&globalThis.crypto?.getRandomValues?globalThis.crypto:null}function generateRandomBytes(byteLength){const cryptoObj=getCrypto();if(cryptoObj){const e=new Uint8Array(byteLength);return cryptoObj.getRandomValues(e),e}try{const nodeRequire="function"==typeof require?require:eval("require"),{randomBytes:randomBytes}=nodeRequire("crypto");return randomBytes(byteLength)}catch(error){throw new Error("Secure random number generation is not supported in this environment.")}}function bytesToHex(e){return Array.from(e,e=>e.toString(16).padStart(2,"0")).join("")}function generateInvitationToken(e={}){const{byteLength:t=DEFAULT_TOKEN_BYTE_LENGTH}=e;if(!Number.isInteger(t)||t<=0)throw new TypeError("byteLength must be a positive integer.");return bytesToHex(generateRandomBytes(t))}function validateInvitationToken(e,t={}){const{minLength:a=2*DEFAULT_TOKEN_BYTE_LENGTH,maxLength:n=2*DEFAULT_TOKEN_BYTE_LENGTH,pattern:r=HEX_TOKEN_REGEX}=t;if("string"!=typeof e)return!1;const i=e.trim();return!(i.length<a||i.length>n)&&r.test(i)}function getInvitationExpiryDate(e={}){const{ttlHours:t=DEFAULT_TOKEN_TTL_HOURS,from:a=new Date}=e;if(!(a instanceof Date)||Number.isNaN(a.getTime()))throw new TypeError("`from` must be a valid Date instance.");if("number"!=typeof t||Number.isNaN(t)||t<=0)throw new TypeError("ttlHours must be a positive number.");const n=new Date(a.getTime());return n.setHours(n.getHours()+t),n}function isInvitationExpired(e,t={}){const{referenceDate:a=new Date}=t;if(!(e instanceof Date)||Number.isNaN(e.getTime()))throw new TypeError("`expiresAt` must be a valid Date instance.");if(!(a instanceof Date)||Number.isNaN(a.getTime()))throw new TypeError("`referenceDate` must be a valid Date instance.");return e.getTime()<=a.getTime()}const INVITATION_TOKEN_DEFAULTS=Object.freeze({BYTE_LENGTH:DEFAULT_TOKEN_BYTE_LENGTH,TTL_HOURS:DEFAULT_TOKEN_TTL_HOURS,PATTERN:HEX_TOKEN_REGEX}),INVITATIONS_COLLECTION="admin_invitations",APPROVED_ADMINS_COLLECTION="approved_admins";function normaliseEmail(e){return"string"!=typeof e?"":e.trim().toLowerCase()}function mapTimestamp(e){return e?e instanceof Date?e:e.toDate?e.toDate():new Date(e):null}function formatInvitationDoc(e){const t=e.data();return{id:e.id,...t,created_at:mapTimestamp(t?.created_at),expires_at:mapTimestamp(t?.expires_at),accepted_at:mapTimestamp(t?.accepted_at),cancelled_at:mapTimestamp(t?.cancelled_at)}}async function findInvitationByToken(e){const t=query(collection(db,INVITATIONS_COLLECTION),where("token","==",e),limit(1)),a=await getDocs(t);return a.empty?null:a.docs[0]}function useAdminInvitations({listen:e=!1}={}){const{currentUser:t,register:a}=useAuth(),{createUserProfile:n}=useUserManagement(),[r,i]=reactExports.useState([]),[o,s]=reactExports.useState(e),[c,m]=reactExports.useState(null);reactExports.useEffect(()=>{if(!e)return i([]),void s(!1);s(!0),m(null);const t=query(collection(db,INVITATIONS_COLLECTION),orderBy("created_at","desc")),a=onSnapshot(t,e=>{const t=e.docs.map(formatInvitationDoc);i(t),m(null),s(!1)},e=>{m(e.message||"Failed to load admin invitations"),s(!1)});return()=>a()},[e]);const u=reactExports.useMemo(()=>r.filter(e=>{if("pending"!==e.status)return!1;if(!e.expires_at)return!0;try{return!isInvitationExpired(e.expires_at)}catch(t){return!0}}),[r]),l=reactExports.useCallback(async({email:e,name:a="",note:n="",ttlHours:r=INVITATION_TOKEN_DEFAULTS.TTL_HOURS}={})=>{const i=normaliseEmail(e);if(!i)throw new Error("A valid email is required to invite an admin.");const o=t?.email??null;if(!o)throw new Error("You must be signed in to send an invitation.");const s=generateInvitationToken(),c=getInvitationExpiryDate({ttlHours:r}),m={email:i,invited_by:o,invited_by_name:t?.displayName||o,status:"pending",token:s,note:n?.trim()||"",expires_at:Timestamp.fromDate(c),created_at:serverTimestamp(),ttl_hours:r,invitee_name:a?.trim()||""},u=await addDoc(collection(db,INVITATIONS_COLLECTION),m);return formatInvitationDoc(await getDoc(u))},[t?.displayName,t?.email]),d=reactExports.useCallback(async e=>{if(!validateInvitationToken(e,{minLength:8,maxLength:256}))return null;const t=e.trim(),a=await findInvitationByToken(t);return a?formatInvitationDoc(a):null},[]),p=reactExports.useCallback(async(e,t)=>{const a=doc(db,INVITATIONS_COLLECTION,e);await updateDoc(a,{status:"accepted",accepted_at:serverTimestamp(),accepted_by:t??null})},[]),T=reactExports.useCallback(async({email:e,name:t,approver:a})=>{const n=doc(db,APPROVED_ADMINS_COLLECTION,e);await setDoc(n,{email:e,name:t||e,approved_by:a||null,approved_at:serverTimestamp(),status:"approved"},{merge:!0})},[]),E=reactExports.useCallback(async({token:e,password:t,name:r})=>{if(!validateInvitationToken(e,{minLength:8,maxLength:256}))throw new Error("Invalid invitation token.");if("string"!=typeof t||t.length<6)throw new Error("Password must be at least 6 characters long.");const i=e.trim(),o=await findInvitationByToken(i);if(!o)throw new Error("Invitation not found or already used.");const s=formatInvitationDoc(o);if("pending"!==s.status)throw new Error("This invitation has already been used or cancelled.");if(s.expires_at&&isInvitationExpired(s.expires_at))throw new Error("This invitation has expired. Please request a new one.");const c=r?.trim()||s.invitee_name||s.email,m=await a(s.email,t);await n(m.uid,{email:s.email,name:c,role:USER_ROLES.ADMIN,status:"approved",approved_at:serverTimestamp(),approved_by:s.invited_by||null}),await p(s.id,m.uid);try{await T({email:s.email,name:c,approver:s.invited_by||null})}catch(u){}return m},[T,n,p,a]),_=reactExports.useCallback(async()=>{const e=query(collection(db,INVITATIONS_COLLECTION),where("status","==","pending"),orderBy("created_at","desc"));return(await getDocs(e)).docs.map(formatInvitationDoc)},[]),v=reactExports.useCallback(async(e,a="")=>{if(!e)throw new Error("Invitation ID is required to cancel an invitation.");const n=doc(db,INVITATIONS_COLLECTION,e);if(!(await getDoc(n)).exists())throw new Error("Invitation not found.");await updateDoc(n,{status:"cancelled",cancelled_at:serverTimestamp(),cancelled_by:t?.email??null,cancellation_reason:a})},[t?.email]);return{invitations:r,pendingInvitations:u,loading:o,error:c,createAdminInvitation:l,getInvitationByToken:d,acceptInvitation:E,getPendingInvitations:_,cancelInvitation:v}}export{isInvitationExpired as i,useAdminInvitations as u};
