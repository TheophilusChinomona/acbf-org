import{a as reactExports}from"./react-vendor-C9V0vZuX.js";import{R as useAuth,a1 as useUserManagement,aq as query,av as orderBy,Y as collection,as as onSnapshot,az as Timestamp,X as addDoc,a5 as getDoc,a4 as doc,a7 as updateDoc,aA as setDoc,W as serverTimestamp,a6 as USER_ROLES,ar as where,at as getDocs,aB as limit,Z as db}from"./index-CCEhIy-z.js";const DEFAULT_TOKEN_BYTE_LENGTH=32,DEFAULT_TOKEN_TTL_HOURS=168,HEX_TOKEN_REGEX=/^[a-f0-9]+$/i;function getCrypto(){return"undefined"!=typeof globalThis&&globalThis.crypto?.getRandomValues?globalThis.crypto:null}function generateRandomBytes(byteLength){const cryptoObj=getCrypto();if(cryptoObj){const t=new Uint8Array(byteLength);return cryptoObj.getRandomValues(t),t}try{const nodeRequire="function"==typeof require?require:eval("require"),{randomBytes:randomBytes}=nodeRequire("crypto");return randomBytes(byteLength)}catch(error){throw new Error("Secure random number generation is not supported in this environment.")}}function bytesToHex(t){return Array.from(t,t=>t.toString(16).padStart(2,"0")).join("")}function generateInvitationToken(t={}){const{byteLength:e=DEFAULT_TOKEN_BYTE_LENGTH}=t;if(!Number.isInteger(e)||e<=0)throw new TypeError("byteLength must be a positive integer.");return bytesToHex(generateRandomBytes(e))}function validateInvitationToken(t,e={}){const{minLength:a=2*DEFAULT_TOKEN_BYTE_LENGTH,maxLength:n=2*DEFAULT_TOKEN_BYTE_LENGTH,pattern:r=HEX_TOKEN_REGEX}=e;if("string"!=typeof t)return!1;const i=t.trim();return!(i.length<a||i.length>n)&&r.test(i)}function getInvitationExpiryDate(t={}){const{ttlHours:e=DEFAULT_TOKEN_TTL_HOURS,from:a=new Date}=t;if(!(a instanceof Date)||Number.isNaN(a.getTime()))throw new TypeError("`from` must be a valid Date instance.");if("number"!=typeof e||Number.isNaN(e)||e<=0)throw new TypeError("ttlHours must be a positive number.");const n=new Date(a.getTime());return n.setHours(n.getHours()+e),n}function isInvitationExpired(t,e={}){const{referenceDate:a=new Date}=e;if(!(t instanceof Date)||Number.isNaN(t.getTime()))throw new TypeError("`expiresAt` must be a valid Date instance.");if(!(a instanceof Date)||Number.isNaN(a.getTime()))throw new TypeError("`referenceDate` must be a valid Date instance.");return t.getTime()<=a.getTime()}const INVITATION_TOKEN_DEFAULTS=Object.freeze({BYTE_LENGTH:DEFAULT_TOKEN_BYTE_LENGTH,TTL_HOURS:DEFAULT_TOKEN_TTL_HOURS,PATTERN:HEX_TOKEN_REGEX}),INVITATIONS_COLLECTION="admin_invitations",APPROVED_ADMINS_COLLECTION="approved_admins";function normaliseEmail(t){return"string"!=typeof t?"":t.trim().toLowerCase()}function mapTimestamp(t){return t?t instanceof Date?t:t.toDate?t.toDate():new Date(t):null}function formatInvitationDoc(t){const e=t.data();return{id:t.id,...e,created_at:mapTimestamp(e?.created_at),expires_at:mapTimestamp(e?.expires_at),accepted_at:mapTimestamp(e?.accepted_at),cancelled_at:mapTimestamp(e?.cancelled_at)}}async function findInvitationByToken(t){const e=query(collection(db,INVITATIONS_COLLECTION),where("token","==",t),limit(1)),a=await getDocs(e);return a.empty?null:a.docs[0]}function useAdminInvitations({listen:t=!1}={}){const{currentUser:e,register:a}=useAuth(),{createUserProfile:n}=useUserManagement(),[r,i]=reactExports.useState([]),[o,s]=reactExports.useState(t),[c,m]=reactExports.useState(null);reactExports.useEffect(()=>{if(!t)return i([]),void s(!1);s(!0),m(null);const e=query(collection(db,INVITATIONS_COLLECTION),orderBy("created_at","desc")),a=onSnapshot(e,t=>{const e=t.docs.map(formatInvitationDoc);i(e),m(null),s(!1)},t=>{m(t.message||"Failed to load admin invitations"),s(!1)});return()=>a()},[t]);const u=reactExports.useMemo(()=>r.filter(t=>{if("pending"!==t.status)return!1;if(!t.expires_at)return!0;try{return!isInvitationExpired(t.expires_at)}catch(e){return!0}}),[r]),l=reactExports.useCallback(async({email:t,name:a="",note:n="",ttlHours:r=INVITATION_TOKEN_DEFAULTS.TTL_HOURS}={})=>{const i=normaliseEmail(t);if(!i)throw new Error("A valid email is required to invite an admin.");const o=e?.email??null;if(!o)throw new Error("You must be signed in to send an invitation.");const s=generateInvitationToken(),c=getInvitationExpiryDate({ttlHours:r}),m={email:i,invited_by:o,invited_by_name:e?.displayName||o,status:"pending",token:s,note:n?.trim()||"",expires_at:Timestamp.fromDate(c),created_at:serverTimestamp(),ttl_hours:r,invitee_name:a?.trim()||""},u=await addDoc(collection(db,INVITATIONS_COLLECTION),m);return formatInvitationDoc(await getDoc(u))},[e?.displayName,e?.email]),d=reactExports.useCallback(async t=>{if(!validateInvitationToken(t,{minLength:8,maxLength:256}))return null;const e=t.trim(),a=await findInvitationByToken(e);return a?formatInvitationDoc(a):null},[]),p=reactExports.useCallback(async(t,e)=>{const a=doc(db,INVITATIONS_COLLECTION,t);await updateDoc(a,{status:"accepted",accepted_at:serverTimestamp(),accepted_by:e??null})},[]),T=reactExports.useCallback(async({email:t,name:e,approver:a})=>{const n=doc(db,APPROVED_ADMINS_COLLECTION,t);await setDoc(n,{email:t,name:e||t,approved_by:a||null,approved_at:serverTimestamp(),status:"approved"},{merge:!0})},[]),E=reactExports.useCallback(async({token:t,password:e,name:r})=>{if(!validateInvitationToken(t,{minLength:8,maxLength:256}))throw new Error("Invalid invitation token.");if("string"!=typeof e||e.length<6)throw new Error("Password must be at least 6 characters long.");const i=t.trim(),o=await findInvitationByToken(i);if(!o)throw new Error("Invitation not found or already used.");const s=formatInvitationDoc(o);if("pending"!==s.status)throw new Error("This invitation has already been used or cancelled.");if(s.expires_at&&isInvitationExpired(s.expires_at))throw new Error("This invitation has expired. Please request a new one.");const c=r?.trim()||s.invitee_name||s.email,m=await a(s.email,e);await n(m.uid,{email:s.email,name:c,role:USER_ROLES.ADMIN,status:"approved",approved_at:serverTimestamp(),approved_by:s.invited_by||null}),await p(s.id,m.uid);try{await T({email:s.email,name:c,approver:s.invited_by||null})}catch(u){}return m},[T,n,p,a]),_=reactExports.useCallback(async()=>{const t=query(collection(db,INVITATIONS_COLLECTION),where("status","==","pending"),orderBy("created_at","desc"));return(await getDocs(t)).docs.map(formatInvitationDoc)},[]),v=reactExports.useCallback(async(t,a="")=>{if(!t)throw new Error("Invitation ID is required to cancel an invitation.");const n=doc(db,INVITATIONS_COLLECTION,t);if(!(await getDoc(n)).exists())throw new Error("Invitation not found.");await updateDoc(n,{status:"cancelled",cancelled_at:serverTimestamp(),cancelled_by:e?.email??null,cancellation_reason:a})},[e?.email]);return{invitations:r,pendingInvitations:u,loading:o,error:c,createAdminInvitation:l,getInvitationByToken:d,acceptInvitation:E,getPendingInvitations:_,cancelInvitation:v}}export{isInvitationExpired as i,useAdminInvitations as u};
